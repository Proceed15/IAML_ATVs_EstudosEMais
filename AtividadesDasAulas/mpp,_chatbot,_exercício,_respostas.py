# -*- coding: utf-8 -*-
"""MPP,_ChatBot,_Exercício,_Respostas.ipynb

Automatically generated by Colab.

Original file is located at Google Colab

# Exercício: Análise Sintática para Chatbot Financeiro

**Entrega: 11/04 às 23h59**

## Contexto

Você faz parte da equipe de desenvolvimento de um assistente virtual para a plataforma **Binacorp**, uma exchange de criptomoedas que oferece suporte automatizado via chatbot. Esse assistente é responsável por interpretar mensagens em linguagem natural de usuários e identificar:

- **Intenção principal** (ex: consultar saldo, transferir fundos, verificar histórico, cancelar operação)
- **Entidades importantes (slots)**:
  - `ativo` (ex: Bitcoin, Ethereum)
  - `quantidade` (número de moedas)
  - `destinatario` (nome da pessoa ou carteira)
  - `data` (quando a ação se refere)
  - `moeda_fiat` (ex: reais, dólares)

Seu time está utilizando a biblioteca **spaCy** para implementar a análise sintática e extrair essas informações com base em dependências gramaticais, categorias morfossintáticas (POS) e palavras-chave.

---

## Situação

O usuário enviou a seguinte mensagem para o chatbot:

> **"Gostaria de transferir 0.5 Bitcoin para o João hoje à noite."**

Com base no comportamento esperado do seu analisador, responda às questões abaixo.

---

## Questões

1. Qual seria a **intenção principal** que o chatbot deve identificar?

2. Quais são os valores esperados dos seguintes **slots** extraídos da frase? Preencha abaixo:

   - `ativo`:  
   - `quantidade`:  
   - `destinatario`:  
   - `data`:  

3. O nome “João” deve ser identificado como qual tipo de palavra? Qual é a **categoria POS (parte do discurso)** mais adequada que o modelo spaCy deve atribuir a ela?

4. Considerando que o horário “à noite” é vago, como o sistema poderia lidar com essa informação para manter a usabilidade do chatbot?

5. Sabendo que o **verbo raiz (ROOT)** da frase indica a ação principal, qual palavra provavelmente será marcada como ROOT nessa sentença? Justifique sua escolha.

# Respostas
Gostaria de transferir 0.5 Bitcoin para o João hoje à noite.

1. Qual seria a **intenção principal** que o chatbot deve identificar?
*R. Gostaria, testando várias vezes ele ainda identifica como gostar e não diretamente transferir, pode ser devido a intenção transferência estar associada a Gostaria de transferir, como o gostaria vêm primeiro ele capta essa por ser a palvra identificada como ROOT. Eu acredito que a intenção que deveria ser identificada como ROOT deveria ser Transferir em todos os casos, é a que melhor se afirma.

2. Quais são os valores esperados dos seguintes **slots** extraídos da frase? Preencha abaixo:

   - `ativo`:  
   - `quantidade`:  
   - `destinatario`:  
   - `data`:  
*R. Ativo: BitCoin
Quantidade: 0.5
Destinatario: João
Data: Hoje à Noite

3. O nome “João” deve ser identificado como qual tipo de palavra? Qual é a **categoria POS (parte do discurso)** mais adequada que o modelo spaCy deve atribuir a ela?
*R. PROPN, um Proper \noun, Nome Próprio

4. Considerando que o horário “à noite” é vago, como o sistema poderia lidar com essa informação para manter a usabilidade do chatbot?
*R. Enviar a quantia a partir das 18:00 até as 2 da manhã

5. Sabendo que o **verbo raiz (ROOT)** da frase indica a ação principal, qual palavra provavelmente será marcada como ROOT nessa sentença? Justifique sua escolha.
*R. Gostaria, mesmo não sendo a ação principal, que eu acredito que seria transferir, por ser o verbo imediatamente anterior a ação principal, acredito que seria escolhido primeiro como verbo raiz

# Código Abaixo para cada questão
"""

# Instalação de dependências
!pip install -q spacy
!python -m spacy download pt_core_news_sm

# Código Resposta da Questão 1
import spacy

nlp = spacy.load("pt_core_news_sm")
doc = nlp("Gostaria de transferir 0.5 Bitcoin para o João hoje à noite.")

# Intenção principal baseada na ROOT
for token in doc:
    if token.dep_ == "ROOT":
        intencao_principal = token.lemma_.lower()

print("Intenção principal:", intencao_principal)

# Código Resposta da Questão 2
ativo = None
quantidade = None
destinatario = None
data = None

for i, token in enumerate(doc):
    if token.like_num:
        quantidade = token.text
        if i + 1 < len(doc) and doc[i + 1].pos_ in ["NOUN", "PROPN"]:
            ativo = doc[i + 1].text

    if token.text.lower() == "para":
        if i + 1 < len(doc):
            prox = doc[i + 1]
            if prox.ent_type_ in ["PER"] or prox.pos_ == "PROPN":
                destinatario = prox.text

    if token.text.lower() == "hoje":
        data = "hoje"
        if i + 2 < len(doc) and doc[i+1].text == "à" and doc[i+2].text.lower() == "noite":
            data += " à noite"

print("ativo:", ativo)
print("quantidade:", quantidade)
print("destinatario:", destinatario)
print("data:", data)

# Código Resposta da Questão 3
for token in doc:
    if token.text == "João":
        typej = token.pos_

print("Tipo da palavra 'João':", typej)
# Basicamente pega o tipo da Palavra João e printamos após o nome

# Código Resposta da Questão 4
# Função para tratar hora vaga
def horario_extractor(data):
    if "noite" in data.lower():
        return "18:01h às 23:59h"
    return "9:00h às 18:00h"

horaAtendimento = horario_extractor("hoje à noite")
print("Horário de Funcionamento para Realizar a Operação:", horaAtendimento)

# Código Resposta da Questão 5
raiz = None
for token in doc:
    if token.dep_ == "ROOT":
        raiz = token.text

print("Palavra ROOT:", raiz)
# Sempre interpreta Gostaria como palavra ROOT nesse contexto

# Instalação de dependências
# !pip install -q spacy
# !python -m spacy download pt_core_news_sm

# Função de interpretação sintática
import spacy

# Carrega modelo de português
nlp = spacy.load("pt_core_news_sm")

def interpretar_frase(frase: str):
    doc = nlp(frase)

    intencao = ""
    nome = ""
    data = ""
    hora = ""

    # 1. Intenção com base no verbo ROOT
    for token in doc:
        if token.dep_ == "ROOT":
            intencao = token.lemma_.lower()  # verbo raiz lematizado

    # 2. Nome próprio
    nomes_proprios = [token.text for token in doc if token.pos_ == "PROPN"]

    for i in range(len(doc)-1):
        if doc[i].text.lower() in ["doutor", "professor", "sr.", "sra."] and doc[i+1].pos_ == "PROPN":
            nome = f"{doc[i].text} {doc[i+1].text}"
            break

    if not nome and nomes_proprios:
        nome = nomes_proprios[0]

    # 3. Data e hora
    for i, token in enumerate(doc):
        if token.text.lower() in ["hoje", "amanhã", "depois"]:
            data = token.text

        if token.like_num and i+1 < len(doc) and doc[i+1].text.lower() == "horas":
            hora = f"{token.text} {doc[i+1].text}"

    # 4. Intenções mapeadas
    mapa_intencoes = {
        "transferir": "transferência",
        "gostar": "transferir",
        "gostaria": "transferência"
    }
    intencao_final = mapa_intencoes.get(intencao, "indefinida")

    return {
        "entrada": frase,
        "intencao": intencao_final,
        "slots": {
            "pessoa": nome,
            "data": data,
            "hora": hora
        },
        "tokens": doc
    }

# Exemplos de teste
entradas = [
    "Gostaria de transferir 0.5 Bitcoin para o João hoje à noite."
]

for frase in entradas:
    resultado = interpretar_frase(frase)
    print("="*70)
    print("Entrada:", resultado["entrada"])
    print("Intenção:", resultado["intencao"])
    print("Slots:", resultado["slots"])
    print(f"{'Token':<15}{'Posição':<10}{'Tipo':<10}{'Dependência':<15}{'Palavra Pai':<15}")
    print("="*70)
    for token in resultado["tokens"]:
        print(f"{token.text:<15}{token.i:<10}{token.pos_:<10}{token.dep_:<15}{token.head.text:<15}")
    print("\n\n")

import spacy

nlp = spacy.load("pt_core_news_sm")
frase = "Gostaria de transferir 0.5 Bitcoin para o João hoje à noite."
doc = nlp(frase)

intencao = ""
nome = ""
data = ""
hora = ""

# 1. Intenção
for token in doc:
    if token.dep_ == "ROOT":
        intencao = token.text.lower()

# 2. Nome próprio
nomes_proprios = [token.text for token in doc if token.pos_ == "PROPN"]

# 3. Data e Hora
for i, token in enumerate(doc):
    if token.text.lower() in ["hoje", "amanhã", "depois"]:
        data = token.text
        #if token.like_num and i+1 < len(doc) and doc[i+1].text.lower() == "noite":
    if token.like_num and i+1 < len(doc) and doc[i+1].text.lower() == "horas":
        hora = f"{token.text} {doc[i+1].text}"

# 4. Nome completo (ex: "doutor João")
for i in range(len(doc)-1):
    if doc[i].text.lower() in ["doutor", "professor", "sr."] and doc[i+1].pos_ == "PROPN":
        nome = f"{doc[i].text} {doc[i+1].text}"

# Resultado final
print("Interpretação da frase:")
print(f"➡ Intenção: {intencao}")
print(f"➡ Pessoa: {nome or nomes_proprios[0]}")
print(f"➡ Data: {data}")
print(f"➡ Hora: {hora}noite")