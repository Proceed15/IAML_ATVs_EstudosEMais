# -*- coding: utf-8 -*-
"""ChatBot Binance, Resolução do Exercicio 28mar.ipynb

Automatically generated by Colab.

Original file is located at Google Colab

### **Exercício: Chatbot para Atendimento Eletrônico em uma Financeira**  

Uma holding financeira deseja implementar um **chatbot de atendimento automático** para agilizar o suporte aos clientes. O chatbot deve ser capaz de **reconhecer intenções**, fornecer respostas adequadas e realizar **análise de sentimentos** para personalizar o atendimento.  

O sistema deve identificar pelo menos três intenções principais, como **saudação, solicitação de informações financeiras e encerramento de atendimento**. Além disso, o chatbot deve classificar o sentimento da mensagem do usuário como **positivo, negativo ou neutro** usando `SentimentIntensityAnalyzer` do `nltk` e ajustar as respostas conforme o contexto.  

Por exemplo, se um cliente disser *"Estou insatisfeito com as taxas cobradas"*, o chatbot pode responder *"Lamentamos saber disso. Podemos verificar melhores condições para você?"*. Já uma mensagem como *"Muito satisfeito com o atendimento!"* pode gerar uma resposta mais positiva, como *"Ficamos felizes em saber disso! Conte sempre conosco."*.  

Implemente o chatbot em **Python no Google Colab**, utilizando **NLTK e um classificador Naïve Bayes** para a identificação das intenções. O código deve estar comentado e conter exemplos de testes com diferentes mensagens. Como desafio extra, expanda as intenções para incluir **simulações de crédito, renegociação de dívidas ou suporte a transações**.

# Resolução Do Exercício

```
# ChatBot para Binance
```
"""

# Bibliotecas

import json
import random
import nltk
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.pipeline import make_pipeline
# from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
from nltk.sentiment.vader import SentimentIntensityAnalyzer

# Baixar recursos do NLTK
nltk.download('punkt')
nltk.download('punkt_tab')
nltk.download('vader_lexicon')
vader = SentimentIntensityAnalyzer();

dataset = {
    "intencoes": [
        {
            "tag": "info",
            "padroes": ["O que é esse aplicativo", "Como funciona", "Vai ser ate quando"],
            "respostas": ["Uma gestora de Finanças com IA", "creditos em até 15 dias depois de comprar", "até hoje"]
        },
        {
            "tag": "credito",
            "padroes": ["Quero crédito", "Emprestimo custa caro", "Quanto é"],
            "respostas": ["Preço Justo a Situação"]
        },
        {
            "tag": "renegociacao",
            "padroes": ["Quero renegociar minha dívida", "Renegociar", "Posso Renegociar"],
            "respostas": ["Se sua dívida for de até 5% do valor total do empréstimo é passível de alteração"]
        },
        {
            "tag": "suporte_transac",
            "padroes": ["Quero concluir minha solicitação de renovação dos meus créditos de juros", "Suporte", "Como Conseguir"],
            "respostas": ["Vá até configurações, aparecerá a opção Atendimento Prioritário, Clique nela e Aguarde mais 30 minutos uma ligação"]
        },
        {
            "tag": "saudacao",
            "padroes": ["Olá!", "Oi", "Tudo bem", "Tudo"],
            "respostas": ["Olá!", "Oi", "Tudo Bem e Você?", "ok, alguma pergunta?"]
        },
        {
            "tag": "despedida",
            "padroes": ["Tchau", "Adeus", "Muito obrigado"],
            "respostas": ["Se tiver mais dúvidas ou precisar de mais informações estou há disposição"]
        }
    ]
}

# Preparação dos dados

intencoes = []
frases = []

for intent in dataset["intencoes"]:
  for padrao in intent["padroes"]:
    frases.append(padrao)
    intencoes.append(intent["tag"])

  print(f"Intenções: {intencoes}");
  print(f"Frase: {frases}");

# Tokenização
# def tokenize(text):
#  return nltk.word_tokenize(text.lower())

# Stemização
# def stem(word):
#  return nltk.stem.WordNetLemmatizer().lemmatize(word.lower())

# Criar Modelo de Classificação
modelo = make_pipeline(TfidfVectorizer(), MultinomialNB())

# treinar Modelo
modelo.fit(frases, intencoes)



# Testes

testes = ["É", "Funciona", "Agora", "Sim", "Olá!", "Oi", "Tchau", "Quero crédito", "Quanto é", "Renegociar", "Suporte"]

# testes = ["É", "Funciona", "Agora", "Sim"]

for teste in testes:
  print(f"Entrada: {teste} --> Intenção Prevista: {modelo.predict([teste])[0]}");

def chatbot(texto):
  intencao_predita = modelo.predict([texto])[0]
  for intent in dataset["intencoes"]:
    if intent["tag"] == intencao_predita:
      return random.choice(intent["respostas"])
    return "Desculpe, não entendi."

#print(f"Chatbot: {chatbot('Como funciona')}")
print(f"Chatbot: {chatbot('Funciona Agora')}")

while True:
  entrada = input("Você: ")
  #entrada = a_entrada.split()
  if entrada.lower() in ["sair", "fechar", "bye bye", "hasta la vista"]:
    print("Chatbot: Até mais!")
    break
  resposta = chatbot(entrada)
  print(f"Chatbot: {resposta}")

atendimentos = "Very Nice"

vader.polarity_scores(atendimentos)